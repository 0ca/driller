--- /home/nick/Projects/junk/safe/afl-1.83b/afl-fuzz.c	2015-06-12 00:50:07.000000000 -0700
+++ afl-fuzz.c	2015-07-17 15:59:29.917713699 -0700
@@ -59,6 +59,8 @@
 #  include <sys/sysctl.h>
 #endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */
 
+#define ELF_EXEC 0
+#define CGC_EXEC 1
 
 /* Lots of globals, but mostly for the status UI and other things where it
    really makes no sense to haul them around as function parameters. */
@@ -66,13 +68,19 @@
 static u8 *in_dir,                    /* Input directory with test cases  */
           *out_file,                  /* File to fuzz, if any             */
           *out_dir,                   /* Working & output directory       */
+          *driller_path,              /* Location of driller executable   */
           *sync_dir,                  /* Synchronization directory        */
           *sync_id,                   /* Fuzzer ID                        */
           *use_banner,                /* Display banner                   */
           *in_bitmap,                 /* Input bitmap                     */
           *doc_path,                  /* Path to documentation dir        */
           *target_path,               /* Path to target binary            */
-          *orig_cmdline;              /* Original command line            */
+          *target_binary_path,        /* Path to target binary, not qemu  */
+          *orig_cmdline,              /* Original command line            */
+          file_type,                  /* ELF or CGC binary?               */
+          *driller_qemu;              /* driller QEMU directory           */
+
+static u8 *driller_procs = "1";       /* Number of driller procs to use   */
 
 static u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */
 static u64 mem_limit = MEM_LIMIT;     /* Memory cap for child (MB)        */
@@ -153,7 +161,8 @@
            bytes_trim_in,             /* Bytes coming into the trimmer    */
            bytes_trim_out,            /* Bytes coming outa the trimmer    */
            blocks_eff_total,          /* Blocks subject to effector maps  */
-           blocks_eff_select;         /* Blocks selected as fuzzable      */
+           blocks_eff_select,         /* Blocks selected as fuzzable      */
+           driller_invokations;       /* Number of driller invokations    */
 
 static u32 subseq_hangs;              /* Number of hangs in a row         */
 
@@ -532,7 +541,7 @@
   fn = alloc_printf("%s/queue/.state/deterministic_done/%s", out_dir, fn + 1);
 
   fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
-  if (fd < 0) PFATAL("Unable to create '%s'", fn);
+  //if (fd < 0) PFATAL("Unable to create '%s'", fn);
   close(fd);
 
   ck_free(fn);
@@ -555,7 +564,7 @@
   if (symlink(ldest, fn)) {
 
     s32 fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
-    if (fd < 0) PFATAL("Unable to create '%s'", fn);
+    //if (fd < 0) PFATAL("Unable to create '%s'", fn);
     close(fd);
 
   }
@@ -586,7 +595,7 @@
   if (state) {
 
     fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
-    if (fd < 0) PFATAL("Unable to create '%s'", fn);
+    //if (fd < 0) PFATAL("Unable to create '%s'", fn);
     close(fd);
 
   } else {
@@ -1242,7 +1251,7 @@
 /* Read all testcases from the input directory, then queue them for testing.
    Called at startup. */
 
-static void read_testcases(void) {
+static void read_testcases(char *in_dir) {
 
   struct dirent **nl;
   s32 nl_cnt;
@@ -1280,6 +1289,10 @@
 
     struct stat st;
 
+    /* jump over driller's traced catalogue */
+    if (!strcmp(nl[i]->d_name, ".traced"))
+        continue;
+
     u8* fn = alloc_printf("%s/%s", in_dir, nl[i]->d_name);
     u8* dfn = alloc_printf("%s/.state/deterministic_done/%s", in_dir, nl[i]->d_name);
 
@@ -2686,7 +2699,7 @@
 
 static void link_or_copy(u8* old_path, u8* new_path) {
 
-  s32 i = link(old_path, new_path);
+  s32 i = 1; //link(old_path, new_path);
   s32 sfd, dfd;
   u8* tmp;
 
@@ -2696,7 +2709,7 @@
   if (sfd < 0) PFATAL("Unable to open '%s'", old_path);
 
   dfd = open(new_path, O_WRONLY | O_CREAT | O_EXCL, 0600);
-  if (dfd < 0) PFATAL("Unable to create '%s'", new_path);
+  if (dfd < 0) { close(sfd); return; } // PFATAL("Unable to create '%s'", new_path);
 
   tmp = ck_alloc(64 * 1024);
 
@@ -3691,7 +3704,7 @@
 
   sprintf(tmp + banner_pad, "%s " cLCY VERSION cLGN
           " (%s)",  crash_mode ? cPIN "peruvian were-rabbit" : 
-          cYEL "american fuzzy lop", use_banner);
+          cYEL "american fuzzy lop " cLBL "(w/ driller)", use_banner);
 
   SAYF("\n%s\n\n", tmp);
 
@@ -3948,6 +3961,8 @@
        "  variable : %s%-10s " bSTG bV "\n", tmp, queued_variable ? cLRD : cNOR,
       no_var_check ? (u8*)"n/a" : DI(queued_variable));
 
+
+
   if (!bytes_trim_out) {
 
     sprintf(tmp, "n/a, ");
@@ -3979,9 +3994,15 @@
 
   }
 
-  SAYF(bV bSTOP "        trim : " cNOR "%-37s " bSTG bVR bH20 bH2 bH2 bRB "\n"
+  //SAYF(bV bSTOP "        trim : " cNOR "%-37s " bSTG bVR bH20 bH2 bH2 bRB "\n"
+  //     bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1, tmp);
+
+
+  sprintf(tmp, "%s", DI(driller_invokations));
+  SAYF(bV bSTOP "     driller : " cNOR "%-37s " bSTG bVR bH20 bH2 bH2 bRB "\n"
        bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1, tmp);
 
+
   /* Provide some CPU utilization stats. */
 
   if (cpu_core_count) {
@@ -6284,6 +6305,12 @@
 
     if (sd_ent->d_name[0] == '.' || !strcmp(sync_id, sd_ent->d_name)) continue;
 
+    u8 *driller_dir = alloc_printf("%s_driller", sync_id);
+    u8 ret = strcmp(driller_dir, sd_ent->d_name);
+    ck_free(driller_dir);
+
+    if (!ret) continue;
+
     /* Skip anything that doesn't have a queue/ subdirectory. */
 
     qd_path = alloc_printf("%s/%s/queue", sync_dir, sd_ent->d_name);
@@ -6517,8 +6544,13 @@
 
 #ifndef __APPLE__
 
+  file_type = ELF_EXEC;
   if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
-    FATAL("Program '%s' is not an ELF binary", target_path);
+  {
+    file_type = CGC_EXEC;
+    if (f_data[0] != 0x7f || memcmp(f_data + 1, "CGC", 3))
+        FATAL("Program '%s' is not an ELF or CGC binary", target_path);
+  }
 
 #else
 
@@ -7166,7 +7198,7 @@
 static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
   char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
-  u8 *tmp, *cp, *rsl, *own_copy;
+  u8 *tmp, *cp, *rsl, *own_copy, *qemu_name, *bpath;
 
   memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
 
@@ -7177,9 +7209,17 @@
 
   tmp = getenv("AFL_PATH");
 
+  if (file_type == ELF_EXEC)
+    qemu_name = "afl-qemu-trace";
+  else if (file_type == CGC_EXEC)
+    qemu_name = "afl-qemu-trace-cgc";
+  else
+    FATAL("Somehow got an unknown file type, not ELF or CGC binary.");
+    
+
   if (tmp) {
 
-    cp = alloc_printf("%s/afl-qemu-trace", tmp);
+    cp = alloc_printf("%s/%s", tmp, qemu_name);
 
     if (access(cp, X_OK))
       FATAL("Unable to find '%s'", tmp);
@@ -7196,7 +7236,8 @@
 
     *rsl = 0;
 
-    cp = alloc_printf("%s/afl-qemu-trace", own_copy);
+    cp = alloc_printf("%s/%s", own_copy, qemu_name);
+
     ck_free(own_copy);
 
     if (!access(cp, X_OK)) {
@@ -7208,9 +7249,11 @@
 
   } else ck_free(own_copy);
 
-  if (!access(BIN_PATH "/afl-qemu-trace", X_OK)) {
+  bpath = alloc_printf("%s/%s", BIN_PATH, qemu_name);
+  if (!access(bpath, X_OK)) {
 
-    target_path = new_argv[0] = ck_strdup(BIN_PATH "/afl-qemu-trace");
+    target_path = new_argv[0] = ck_strdup(bpath);
+    ck_free(bpath);
     return new_argv;
 
   }
@@ -7257,6 +7300,48 @@
 
 }
 
+/* Functions for driller */
+void invoke_driller(char **use_argv)
+{
+    pid_t driller_pid;
+    char *argv[10];
+    char *driller_out;
+
+    SAYF(cYEL "[!]" cRST " driller being invoked!\n");
+
+    /* if a sync_id was specified our output directory is in the the sync_dir */
+    if (sync_id) 
+        driller_out = alloc_printf("%s/%s_driller/", sync_dir, sync_id);
+    else
+        driller_out = alloc_printf("%s/driller/", out_dir);
+
+    printf("driller going now!\n");
+    fflush(stdout);
+
+    argv[0]  = driller_path;
+    argv[1]  = "-b";
+    argv[2]  = target_binary_path;
+    argv[3]  = "-i";
+    argv[4]  = alloc_printf("%s/queue", out_dir);
+    argv[5]  = "-f";
+    argv[6] = alloc_printf("%s/fuzz_bitmap", out_dir); 
+    argv[7] = "-q";
+    argv[8] = driller_qemu;
+    argv[9] = NULL;
+
+
+    driller_pid = fork();
+    if (driller_pid == 0)
+    {
+        execve(driller_path, argv, environ);
+        exit(1); 
+    }
+
+    if (driller_pid < 0)
+    {
+        perror("failed to invoke driller");
+    }  
+}
 
 /* Main entry point */
 
@@ -7274,7 +7359,7 @@
 
   doc_path = access(DOC_PATH, F_OK) ? "docs" : DOC_PATH;
 
-  while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:Q")) > 0)
+  while ((opt = getopt(argc, argv, "+i:o:D:j:q:f:m:t:T:dnCB:S:M:x:Q")) > 0)
 
     switch (opt) {
 
@@ -7293,6 +7378,22 @@
         out_dir = optarg;
         break;
 
+      case 'D': /* driller */
+
+        if (driller_path) FATAL("Multiple -D options not supported");
+        driller_path = optarg;
+        break;
+
+      case 'j': /* driller processes */
+        
+        driller_procs = optarg;
+        break;
+
+      case 'q': /* driller qemu directory */
+
+        driller_qemu = optarg;
+        break;
+
       case 'M':
 
         force_deterministic = 1;
@@ -7470,7 +7571,7 @@
   setup_shm();
 
   setup_dirs_fds();
-  read_testcases();
+  read_testcases(in_dir);
   load_auto();
 
   pivot_inputs();
@@ -7487,6 +7588,7 @@
 
   start_time = get_cur_time();
 
+  target_binary_path = argv[optind];
   if (qemu_mode)
     use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
   else
@@ -7557,6 +7659,20 @@
 
     skipped_fuzz = fuzz_one(use_argv);
 
+    /* when AFL goes blue we invoke driller */
+    if (cycles_wo_finds > 0 && unique_crashes == 0 && !force_deterministic && driller_path)
+    {
+        if (sync_id)
+            sync_fuzzers(use_argv); /* try to sync fuzzers first */
+
+        /* still didn't find anything interesting after a sync, invoke driller */
+        if (cycles_wo_finds > 0)
+        {
+            invoke_driller(use_argv);
+            cycles_wo_finds = 0;
+        }
+    } 
+
     if (!stop_soon && sync_id && !skipped_fuzz) {
       
       if (!(sync_interval_cnt++ % SYNC_INTERVAL))
